## Introduction
This article shares my term project for Carnegie Mellon University's 15112 course (Fundamentals of Programming) - a SpongeBob-themed 2D platform game developed in Python. The project utilizes the `cmu_112_graphics` library provided by the course to simplify graphics and animation handling. This article demonstrates how I built a simple game from scratch, including game design, code implementation, and key programming techniques.

## Project Background
This project was the term assignment for CMU 15112, designed to reinforce programming concepts learned in class through practical application. The requirements were to design and implement a moderately complex game, and I chose to develop a 2D platformer.

## Game Design
Inspired by classic platformer games, players control SpongeBob to move across platforms, collect Krabby Patties, and avoid Plankton's pursuit. The game features two levels with different layouts and challenges. Players can control SpongeBob's movement using keyboard inputs and use weapons to defeat Plankton.

## Tech Stack
* Programming Language: Python
* Graphics Library: `cmu_112_graphics` (simplified graphics library provided by CMU 15112)
* Resource Management: Loading and using image/sound files
* Game Logic: Collision detection, character movement, level design

## Code Structure
The game code is organized into four main components:
1. **Game Initialization**: Setting basic parameters like window size, loading images/sounds
2. **Game Logic**: Handling player input, updating game state, collision detection
3. **Game Rendering**: Drawing game elements (background, platforms, characters, weapons)
4. **Game Over**: Handling win/lose conditions and displaying appropriate screens

## Key Code Analysis

### 1. Game Initialization
The `appStarted` function initializes game resources including images, sounds, character positions, and platform layouts:

```python
def appStarted(app):
    app.sound_win = Sound('win.mp3')
    app.sound_lose = Sound('lose.mp3')
    app.sound_hit = Sound('hit.mp3')
    app.sound = Sound('music.mp3')
    app.image_url = app.loadImage('background.png')
    app.image_SBSP = app.loadImage('SBSP.png')
    app.image_KB = app.loadImage('KB.png')
    app.image_platform = app.loadImage('platform.png')
    app.image_ladd = app.loadImage('ladder2.png')
    app.sprites = [app.loadImage(f'P{i}.png') for i in range(5)]
    app.spriteCounter = 0
    # Other initialization code...
2. Game Logic

The keyPressed and timerFired functions handle player input and game state updates:
def keyPressed(app, event):
    if event.key == 'Up':
        app.SBSP_y1 -= app.SBSP_v1
    elif event.key == 'Down':
        app.SBSP_y1 += app.SBSP_v1
    elif event.key == 'Left':
        app.SBSP_x1 -= app.SBSP_v1
    elif event.key == 'Right':
        app.SBSP_x1 += app.SBSP_v1
    elif event.key == 'Space':
        if ShotPlankton(app, app.SBSP_x1, app.SBSP_y1, app.P1_x, app.P1_y):
            app.weapon -= 1
            app.lives += 1
3. Game Rendering

The redrawAll function draws all game elements:
def redrawAll(app, canvas):
    if app.screencount == 0:
        DrawStartScreen(app, canvas)
    elif app.screencount == 1:
        DrawLevel1(app, canvas)
    elif app.screencount == 2:
        DrawLevel2(app, canvas)
    elif app.screencount == 4:
        DrawLose(app, canvas)
    elif app.screencount == 5:
        DrawWin(app, canvas)
4. Game Over

Win/lose screens are displayed when appropriate:
def DrawLose(app, canvas):
    canvas.create_image(500, 300, image=ImageTk.PhotoImage(app.image_lose2))
    canvas.create_text(app.width//2, app.height//9, 
                      text="Press 'r' to restart", font='Arial 30 bold')

def DrawWin(app, canvas):
    canvas.create_image(500, 300, image=ImageTk.PhotoImage(app.image_win2))
    canvas.create_text(app.width//2, app.height//9, 
                      text="You Win!", font='Arial 30 bold')
Challenges and Solutions

Collision Detection: Implemented efficient collision logic using geometric calculations
Resource Management: Carefully managed loading/releasing of multiple image/sound assets
Level Design: Balanced difficulty and fun factor across different level layouts
Conclusion

This project not only reinforced my programming knowledge from CMU 15112 but also deepened my understanding of key game development concepts like resource management, input handling, collision detection, and game state management. I hope this article inspires you to begin your own game development journey!

Feel free to leave comments or questions below!
